[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Geocomputation with Julia",
    "section": "",
    "text": "Welcome\nThis is the online home of Geocomputation with Julia, a book on reproducible geographic data analysis with open source software.\nInspired by the Free and Open Source Software for Geospatial (FOSS4G) movement this is an open source book. Find the code underlying the geocompjl project on GitHub, ensuring that the content is reproducible, transparent, and accessible. Making the book open source allows you or anyone else, to interact with the project by opening issues, making typo fixes and more, for the benefit of everyone.\nThis book is part of the geocompx series, following the popular R and Python editions.\nThe book’s website is built by GitHub Actions, which runs the code every time we make a change, ensuring code correctness and reproducibility. The current build status as follows:\n\nFor details on reproducing the book, see the README in the project’s GitHub repo: https://github.com/geocompx/geocompjl.\n\nprint(\"Hello geocompx World\")\n\nHello geocompx World",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "chapters/01-spatial-data.html",
    "href": "chapters/01-spatial-data.html",
    "title": "2  Geographic data in Julia",
    "section": "",
    "text": "2.1 Introduction\nusing GeoDataFrames\ndf = GeoDataFrames.read(\"data/world.gpkg\")\n\n177×11 DataFrame171 rows omitted\n\n\n\nRow\ngeom\niso_a2\nname_long\ncontinent\nregion_un\nsubregion\ntype\narea_km2\npop\nlifeExp\ngdpPercap\n\n\n\nIGeometr…\nString?\nString\nString\nString\nString\nString\nFloat64\nFloat64?\nFloat64?\nFloat64?\n\n\n\n\n1\nGeometry: wkbMultiPolygon\nFJ\nFiji\nOceania\nOceania\nMelanesia\nSovereign country\n19290.0\n885806.0\n69.96\n8222.25\n\n\n2\nGeometry: wkbMultiPolygon\nTZ\nTanzania\nAfrica\nAfrica\nEastern Africa\nSovereign country\n9.32746e5\n5.22349e7\n64.163\n2402.1\n\n\n3\nGeometry: wkbMultiPolygon\nEH\nWestern Sahara\nAfrica\nAfrica\nNorthern Africa\nIndeterminate\n96270.6\nmissing\nmissing\nmissing\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n175\nGeometry: wkbMultiPolygon\nXK\nKosovo\nEurope\nEurope\nSouthern Europe\nSovereign country\n11230.3\n1.8218e6\n71.0976\n8698.29\n\n\n176\nGeometry: wkbMultiPolygon\nTT\nTrinidad and Tobago\nNorth America\nAmericas\nCaribbean\nSovereign country\n7737.81\n1.35449e6\n70.426\n31181.8\n\n\n177\nGeometry: wkbMultiPolygon\nSS\nSouth Sudan\nAfrica\nAfrica\nEastern Africa\nSovereign country\n6.24909e5\n1.1531e7\n55.817\n1935.88\nusing CairoMakie\nusing GeoMakie\n\nf, a, p = poly(df.geom)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Geographic data in Julia</span>"
    ]
  },
  {
    "objectID": "chapters/01-spatial-data.html#introduction",
    "href": "chapters/01-spatial-data.html#introduction",
    "title": "2  Geographic data in Julia",
    "section": "",
    "text": "2.1.1 Raster from scratch\nIn this section, we are going to demonstrate the creation of rasters from scratch. We will construct two small rasters, elev and grain, which we will use in examples later in the book. Unlike creating a vector layer (see ?sec-vector-layer-from-scratch), creating a raster from scratch is rarely needed in practice because aligning a raster with the proper spatial extent is challenging to do programmatically (“georeferencing” tools in GIS software are a better fit for the job). Nevertheless, the examples will be helpful to become more familiar with the Rasters.jl data structures.\n\nusing Rasters\nimport GeoFormatTypes as GFT\n\nConceptually, a raster is an array combined with georeferencing information, whereas the latter comprises:\n\nLookup vectors for the axes, encoding the spatial coordinates for each grid cell. These take the form of the X and Y dimensions in the raster that you’ll see below.\nA coordinate reference system (CRS) definition, specifying the association of the raster’s coordinates with the surface of the earth.\n\nTherefore, to create a raster, we first need to have an array with the values, and then supplement it with the georeferencing information. Let’s create the arrays elev and grain. The elev array is a \\(6 \\times 6\\) array with sequential values from 1 to 36. It can be created as follows using base Julia functions.\n\nelev = reshape(UInt8(1):UInt8(36), (6, 6))\n\n6×6 reshape(::UnitRange{UInt8}, 6, 6) with eltype UInt8:\n 0x01  0x07  0x0d  0x13  0x19  0x1f\n 0x02  0x08  0x0e  0x14  0x1a  0x20\n 0x03  0x09  0x0f  0x15  0x1b  0x21\n 0x04  0x0a  0x10  0x16  0x1c  0x22\n 0x05  0x0b  0x11  0x17  0x1d  0x23\n 0x06  0x0c  0x12  0x18  0x1e  0x24\n\n\nThe grain array represents a categorical raster with values 0, 1, 2, corresponding to categories “clay”, “silt”, “sand”, respectively. We will create it from a specific arrangement of pixel values, using reshape.\n\nv = UInt8[\n  1, 0, 1, 2, 2, 2, \n  0, 2, 0, 0, 2, 1, \n  0, 2, 2, 0, 0, 2, \n  0, 0, 1, 1, 1, 1, \n  1, 1, 1, 2, 1, 1, \n  2, 1, 2, 2, 0, 2\n]\ngrain = reshape(v, (6, 6))\n\n6×6 Matrix{UInt8}:\n 0x01  0x00  0x00  0x00  0x01  0x02\n 0x00  0x02  0x02  0x00  0x01  0x01\n 0x01  0x00  0x02  0x01  0x01  0x02\n 0x02  0x00  0x00  0x01  0x02  0x02\n 0x02  0x02  0x00  0x01  0x01  0x00\n 0x02  0x01  0x02  0x01  0x01  0x02\n\n\nNote that in both cases, we are using the uint8 (unsigned integer in 8 bits, i.e., 0-255) data type, which is sufficient to represent all possible values of the given rasters (see ?tbl-numpy-data-types). This is the recommended approach for a minimal memory footprint.\nWhat is missing now is the georeferencing information (see ?sec-using-rasters-jl). In this case, since the rasters are arbitrary, we also set up arbitrary dimension lookups for the x and y axes, where:\n\nThe origin (\\(x_{min}\\), \\(y_{max}\\)) is at -1.5,1.5\nThe raster resolution (\\(delta_{x}\\), \\(delta_{y}\\)) is 0.5,-0.5\n\nWe can add this information using rasterio.transform.from_origin, and specifying west, north, xsize, and ysize parameters. The resulting transformation matrix object is hereby named new_transform.\n\nnew_x = X(range(-1.5, step=0.5, length=6))\nnew_y = Y(range(1.0, step=-0.5, length=6))\n\nY 1.0:-0.5:-1.5\n\n\nWe can now construct a Raster object, from the elev array and the dimensions new_x and new_y.\nWe assign to it a CRS of EPSG:4326 (which encodes that the coordinate system is longitude/latitude on the “standard” WGS84 definition of the Earth’s curvature).\nHere, we use the GFT.EPSG(code) constructor to create an object that encodes a reference code under the European Petroleum Survey Group (EPSG) authority’s database of coordinate reference systems.\n\nelev_raster = Raster(elev, (new_x, new_y); crs = GFT.EPSG(4326))\n\n╭─────────────────────╮\n│ 6×6 Raster{UInt8,2} │\n├─────────────────────┴──────────────────────────────────────── dims ┐\n  ↓ X Projected{Float64} -1.5:0.5:1.0 ForwardOrdered Regular Points,\n  → Y Projected{Float64} 1.0:-0.5:-1.5 ReverseOrdered Regular Points\n├──────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-1.5, 1.0), Y = (-1.5, 1.0))\n  crs: EPSG:4326\n└────────────────────────────────────────────────────────────────────┘\n  ↓ →     1.0     0.5     0.0    -0.5    -1.0    -1.5\n -1.5  0x01    0x07    0x0d    0x13    0x19    0x1f\n -1.0  0x02    0x08    0x0e    0x14    0x1a    0x20\n -0.5  0x03    0x09    0x0f    0x15    0x1b    0x21\n  0.0  0x04    0x0a    0x10    0x16    0x1c    0x22\n  0.5  0x05    0x0b    0x11    0x17    0x1d    0x23\n  1.0  0x06    0x0c    0x12    0x18    0x1e    0x24\n\n\nThe raster can now be plotted in its coordinate system, passing the array elev along with the transformation matrix new_transform to rasterio.plot.show (Figure 2.1).\n\nplot(elev_raster)\n\n\n\n\n\n\n\nFigure 2.1: Plot of the elev raster, a minimal example of a continuous raster, created from scratch\n\n\n\n\n\nThe grain raster can be plotted the same way, as we are going to use the same transformation matrix for it as well (Figure 2.2).\n\nplot(Raster(grain, (new_x, new_y); crs = GFT.EPSG(4326)))\n\n\n\n\n\n\n\nFigure 2.2: Plot of the grain raster, a minimal example of a categorical raster, created from scratch\n\n\n\n\n\nAt this point, we have two rasters, each composed of an array and related dimension lookups. We can work with the raster using Rasters.jl by:\n\nKeeping in mind that any other layer we use in the analysis is in the same CRS\n\nFinally, to export the raster for permanent storage, along with the spatial metadata, we need to go through the following steps:\n\nCreate a raster file (where we set the lookups and the CRS, among other settings)\nWrite the array with raster values into the connection\nClose the connection\n\nDon’t worry if the code below is unclear; the concepts related to writing raster data to file will be explained in ?sec-data-output-raster. For now, for completeness, and also to use these rasters in subsequent chapters without having to re-create them from scratch, we just provide the code for exporting the elev and grain rasters into the output directory. In the case of elev, we do it as follows with the Rasters.write functions and methods of the Rasters.jl package.\n\nwrite(\"output/elev.tif\", elev_raster; force = true)\n\n\"output/elev.tif\"\n\n\nNote that the CRS we (arbitrarily) set for the elev raster is WGS84, defined using crs=4326 according to the EPSG code.\nExporting the grain raster is done in the same way, with the only differences being the file name and the array we write into the connection.\n\nwrite(\"output/grain.tif\", Raster(grain, (new_x, new_y); crs = GFT.EPSG(4326)); force = true)\n\n\"output/grain.tif\"\n\n\nAs a result, the files elev.tif and grain.tif are written into the output directory. We are going to use these small raster files later on in the examples (for example, ?sec-raster-subsetting).\nNote that the transform matrices and dimensions of elev and grain are identical. This means that the rasters are overlapping, and can be combined into one two-band raster, processed in raster algebra operations (?sec-map-algebra), etc.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Geographic data in Julia</span>"
    ]
  },
  {
    "objectID": "chapters/02-attribute-operations.html",
    "href": "chapters/02-attribute-operations.html",
    "title": "3  Attribute data operations",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Attribute data operations</span>"
    ]
  },
  {
    "objectID": "chapters/03-spatial-operations.html",
    "href": "chapters/03-spatial-operations.html",
    "title": "4  Spatial data operations",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Spatial data operations</span>"
    ]
  },
  {
    "objectID": "chapters/04-geometry-operations.html",
    "href": "chapters/04-geometry-operations.html",
    "title": "5  Geometry operations",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geometry operations</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html",
    "href": "chapters/05-raster-vector.html",
    "title": "6  Raster-vector interactions",
    "section": "",
    "text": "Prerequisites\nThis chapter requires importing the following packages:\nusing GeoDataFrames, DataFrames\nusing Rasters, ArchGDAL # Raster I/O and operations\nusing Proj # activate reprojection capabilities\nimport GeoInterface as GI, GeometryOps as GO, LibGEOS as LG # Vector operations\nimport GeoFormatTypes as GFT # for CRS types\nusing GeoMakie, CairoMakie # plotting\nHere, we will also set the theme in Makie.jl to ensure that all surface and heatmap plots are represented in file as bitmap images, rather than the raw data.\nThis is necessary only because Quarto breaks on SVGs above a certain size.\nYou can feel free to set this for your own work, but it is not required.\nMakie.set_theme!(\n    Heatmap = (; rasterize = 2),\n    Surface = (; rasterize = 2),\n)\nIt also relies on the following data files:\nsrc_srtm = Raster(\"data/srtm.tif\")\nsrc_nlcd = Raster(\"data/nlcd.tif\")\nsrc_grain = Raster(\"output/grain.tif\")\nsrc_elev = Raster(\"output/elev.tif\")\nsrc_dem = Raster(\"data/dem.tif\")\nzion = GeoDataFrames.read(\"data/zion.gpkg\")\nzion_points = GeoDataFrames.read(\"data/zion_points.gpkg\")\ncycle_hire_osm = GeoDataFrames.read(\"data/cycle_hire_osm.gpkg\")\nus_states = GeoDataFrames.read(\"data/us_states.gpkg\")\nnz = GeoDataFrames.read(\"data/nz.gpkg\")\nsrc_nz_elev = Raster(\"data/nz_elev.tif\")\n\n╭─────────────────────────────────────────────╮\n│ 1115×1450 Raster{Union{Missing, Float32},2} │\n├─────────────────────────────────────────────┴────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(995456.5461976258, 2.109456546197626e6, 1115) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(6.190960927303582e6, 4.741960927303582e6, 1450) ReverseOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata{Rasters.GDALsource} of Dict{String, Any} with 1 entry:\n  \"filepath\" =&gt; \"data/nz_elev.tif\"\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (995456.5461976258, 2.110456546197626e6), Y = (4.741960927303582e6, 6.191960927303582e6))\n  missingval: missing\n  crs: PROJCS[\"unknown\",GEOGCS[\"unknown\",DATUM[\"Unknown based on GRS80 ellipsoid\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",173],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",1600000],PARAMETER[\"false_northing\",10000000],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]\n└──────────────────────────────────────────────────────────────────────────────┘\n ↓ →        6.19096e6  6.18996e6  …  4.74396e6  4.74296e6  4.74196e6\n 9.95457e5   missing    missing       missing    missing    missing\n 9.96457e5   missing    missing       missing    missing    missing\n ⋮                                ⋱                        ⋮\n 2.10746e6   missing    missing       missing    missing    missing\n 2.10846e6   missing    missing       missing    missing    missing\n 2.10946e6   missing    missing   …   missing    missing    missing",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html#introduction",
    "href": "chapters/05-raster-vector.html#introduction",
    "title": "6  Raster-vector interactions",
    "section": "6.1 Introduction",
    "text": "6.1 Introduction\nThis chapter focuses on interactions between raster and vector geographic data models, both introduced in Chapter 2. It includes four main techniques:\n\nRaster cropping and masking using vector objects (Section 6.2)\nExtracting raster values using different types of vector data (Section 6.3)\nRaster to vector conversion (Section 6.4)\nVector to raster conversion (Section 6.5)\n\nThese concepts are demonstrated using data from previous chapters, to understand their potential real-world applications.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html#sec-raster-cropping",
    "href": "chapters/05-raster-vector.html#sec-raster-cropping",
    "title": "6  Raster-vector interactions",
    "section": "6.2 Raster masking and cropping",
    "text": "6.2 Raster masking and cropping\nMany geographic data projects involve integrating data from many different sources, such as remote sensing images (rasters) and administrative boundaries (vectors). Often the extent of input raster datasets is larger than the area of interest. In this case, raster masking, cropping, or both, are useful for unifying the spatial extent of input data (Figure 6.1 (b) and (c), and the following two examples, illustrate the difference between masking and cropping). Both operations reduce object memory use and associated computational resources for subsequent analysis steps, and may be a necessary preprocessing step before creating attractive maps involving raster data.\nWe will use two layers to illustrate raster cropping:\n\nThe srtm.tif raster representing elevation, in meters above sea level, in south-western Utah: a Rasters.jl file connection named src_srtm (see Figure 6.1 (a))\nThe zion.gpkg vector layer representing the Zion National Park boundaries (a DataFrame named zion)\n\nBoth target and cropping objects must have the same projection. Since it is easier and more precise to reproject vector layers, compared to rasters, we use the following expression to reproject (?sec-reprojecting-vector-geometries) the vector layer zion into the coordinate reference system (CRS) of the raster src_srtm. The CRS defines how the coordinates of the geometry relate to locations on the surface of the Earth.\n\nzion = GO.reproject(zion; target_crs = GI.crs(src_srtm))\n\n1×12 DataFrame\n\n\n\nRow\ngeom\nUNIT_CODE\nGIS_Notes\nUNIT_NAME\nDATE_EDIT\nSTATE\nREGION\nGNIS_ID\nUNIT_TYPE\nCREATED_BY\nMETADATA\nPARKNAME\n\n\n\nPolygon…\nString\nString\nString\nDateTime\nString\nString\nString\nString\nString\nString\nString\n\n\n\n\n1\nPolygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{CRS}}}, Nothing, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{CRS}}([(-113.084, 37.1713), (-113.086, 37.1716), (-113.091, 37.1722), (-113.091, 37.1744), (-113.091, 37.178), (-113.091, 37.1817), (-113.091, 37.1853), (-113.091, 37.1889), (-113.091, 37.1926), (-113.091, 37.1962) … (-113.06, 37.1713), (-113.062, 37.1713), (-113.064, 37.1713), (-113.069, 37.1713), (-113.071, 37.1713), (-113.073, 37.1713), (-113.078, 37.1713), (-113.08, 37.1713), (-113.082, 37.1713), (-113.084, 37.1713)], nothing, WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], nothing, WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))\nZION\nLands - http://landsnet.nps.gov/tractsnet/documents/ZION/Metadata/zion_metadata.xml\nZion National Park\n2017-06-22T00:00:00\nUT\nIM\n1455157\nNational Park\nLands\nhttps://irma.nps.gov/App/Reference/Profile/2181118#Zion National Monument\nZion\n\n\n\n\n\n\nTo mask the image, i.e., convert all pixels which do not intersect with the zion polygon to missing, we use the Rasters.mask function.\nmask supports any geometry, vector of geometries, feature collection, or table with a geometry column!\nThe tabset below shows all the different ways to mask a raster. We’ll go forward with the approach of using a DataFrame.\n\nDataFrameSingle geometryVector of geometries\n\n\n\nout_image_mask = Rasters.mask(src_srtm; with = zion)\n\n╭──────────────────────────────────────────╮\n│ 465×457 Raster{Union{Missing, UInt16},2} │\n├──────────────────────────────────────────┴───────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(-113.23958321278403, -112.85291654614313, 465) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(37.51208342983253, 37.13208342985786, 457) ReverseOrdered Regular Intervals{Start}\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-113.23958321278403, -112.85208321280986), Y = (37.13208342985786, 37.512916763165805))\n  missingval: missing\n  crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →    37.5121    37.5113    …  37.1338    37.1329    37.1321\n -113.24     missing    missing       missing    missing    missing\n -113.239    missing    missing       missing    missing    missing\n -113.238    missing    missing       missing    missing    missing\n -113.237    missing    missing       missing    missing    missing\n    ⋮                            ⋱   ⋮                    \n -112.856    missing    missing       missing    missing    missing\n -112.855    missing    missing       missing    missing    missing\n -112.855    missing    missing       missing    missing    missing\n -112.854    missing    missing       missing    missing    missing\n -112.853    missing    missing  …    missing    missing    missing\n\n\n\n\n\nmasker = zion.geom[1]\n\nGeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(-113.08438684283465, 37.17130388117393), (-113.0859893948904, 37.17162779353809), (-113.09132351665151, 37.17215207288513), (-113.09132530000656, 37.17440980000173), (-113.09132830000658, 37.17803750000173), (-113.09133150000655, 37.18166840000168), (-113.09133470000658, 37.18529940000173), (-113.09134070000657, 37.188925000001696), (-113.09134660000655, 37.19255060000173), (-113.09135260000657, 37.19617620000171)  …  (-113.05962130000604, 37.17131270000172), (-113.06185720000607, 37.171310800001734), (-113.06415140000612, 37.17131020000169), (-113.06868130000619, 37.17130650000175), (-113.07101920000618, 37.17130460000174), (-113.07321130000625, 37.17130450000173), (-113.07773970000633, 37.17130420000172), (-113.08035690000636, 37.17130410000175), (-113.0822681000064, 37.171304000001705), (-113.08438684283465, 37.17130388117393)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))\n\n\n\nRasters.mask(src_srtm; with = masker)\n\n╭──────────────────────────────────────────╮\n│ 465×457 Raster{Union{Missing, UInt16},2} │\n├──────────────────────────────────────────┴───────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(-113.23958321278403, -112.85291654614313, 465) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(37.51208342983253, 37.13208342985786, 457) ReverseOrdered Regular Intervals{Start}\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-113.23958321278403, -112.85208321280986), Y = (37.13208342985786, 37.512916763165805))\n  missingval: missing\n  crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →    37.5121    37.5113    …  37.1338    37.1329    37.1321\n -113.24     missing    missing       missing    missing    missing\n -113.239    missing    missing       missing    missing    missing\n -113.238    missing    missing       missing    missing    missing\n -113.237    missing    missing       missing    missing    missing\n    ⋮                            ⋱   ⋮                    \n -112.856    missing    missing       missing    missing    missing\n -112.855    missing    missing       missing    missing    missing\n -112.855    missing    missing       missing    missing    missing\n -112.854    missing    missing       missing    missing    missing\n -112.853    missing    missing  …    missing    missing    missing\n\n\n\n\n\nmasker = zion.geom\n\n1-element Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}}:\n GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(-113.08438684283465, 37.17130388117393), (-113.0859893948904, 37.17162779353809), (-113.09132351665151, 37.17215207288513), (-113.09132530000656, 37.17440980000173), (-113.09132830000658, 37.17803750000173), (-113.09133150000655, 37.18166840000168), (-113.09133470000658, 37.18529940000173), (-113.09134070000657, 37.188925000001696), (-113.09134660000655, 37.19255060000173), (-113.09135260000657, 37.19617620000171)  …  (-113.05962130000604, 37.17131270000172), (-113.06185720000607, 37.171310800001734), (-113.06415140000612, 37.17131020000169), (-113.06868130000619, 37.17130650000175), (-113.07101920000618, 37.17130460000174), (-113.07321130000625, 37.17130450000173), (-113.07773970000633, 37.17130420000172), (-113.08035690000636, 37.17130410000175), (-113.0822681000064, 37.171304000001705), (-113.08438684283465, 37.17130388117393)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))\n\n\n\nRasters.mask(src_srtm; with = masker)\n\n╭──────────────────────────────────────────╮\n│ 465×457 Raster{Union{Missing, UInt16},2} │\n├──────────────────────────────────────────┴───────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(-113.23958321278403, -112.85291654614313, 465) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(37.51208342983253, 37.13208342985786, 457) ReverseOrdered Regular Intervals{Start}\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-113.23958321278403, -112.85208321280986), Y = (37.13208342985786, 37.512916763165805))\n  missingval: missing\n  crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →    37.5121    37.5113    …  37.1338    37.1329    37.1321\n -113.24     missing    missing       missing    missing    missing\n -113.239    missing    missing       missing    missing    missing\n -113.238    missing    missing       missing    missing    missing\n -113.237    missing    missing       missing    missing    missing\n    ⋮                            ⋱   ⋮                    \n -112.856    missing    missing       missing    missing    missing\n -112.855    missing    missing       missing    missing    missing\n -112.855    missing    missing       missing    missing    missing\n -112.854    missing    missing       missing    missing    missing\n -112.853    missing    missing  …    missing    missing    missing\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that since Julia has a native missing/NODATA value type, we don’t need to specify a NODATA value for the mask function.\nHowever, it can sometimes be useful and more efficient to specify a sentinel value which Rasters treats as missing.\nYou can do this by specifying the missingval keyword argument, like so:\nout_image_mask = Rasters.mask(src_srtm; with = zion, missingval = 9999)\n\n\nWe can write this masked raster to file with Rasters.write, as usual:\n\nRasters.write(\"output/srtm_masked.tif\", out_image_mask; force = true\n)\n\n[ Info: `missingval` set to 65535 on disk\n\n\n\"output/srtm_masked.tif\"\n\n\nIn Rasters.jl, cropping and masking are distinct operations. Cropping, which reduces the raster extent to the extent of the vector layer, is accomplished with the crop function.\nHere, we simply pass the zion feature table to the to keyword argument, which indicates what to crop the raster “to”. We also set the touches keyword argument to true, to specify that pixels that partially overlap with the vector layer are included in the output.\n\nout_image_crop = Rasters.crop(src_srtm; to = zion, touches = true)\n\n╭──────────────────────────────────────────╮\n│ 439×436 Raster{Union{Missing, UInt16},2} │\n├──────────────────────────────────────────┴───────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(-113.22874987945141, -112.86374987947575, 439) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(37.50375009649975, 37.14125009652391, 436) ReverseOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata{Rasters.GDALsource} of Dict{String, Any} with 1 entry:\n  \"filepath\" =&gt; \"data/srtm.tif\"\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-113.22874987945141, -112.86291654614247), Y = (37.14125009652391, 37.504583429833026))\n  missingval: missing\n  crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →        37.5038      37.5029      37.5021  …      37.1421      37.1413\n -113.229  0x0668       0x065f       0x0659          0x05a0       0x05df\n -113.228  0x0663       0x065e       0x0658          0x059e       0x05e4\n    ⋮                                             ⋱       ⋮       \n -112.865  0x09db       0x09e2       0x09e7          0x06d4       0x06d0\n -112.865  0x09ef       0x0a02       0x0a0b          0x06d9       0x06d4\n -112.864  0x0a00       0x0a1a       0x0a24          0x06da       0x06d4\n\n\nYou can also assemble an extent manually, using Extents.Extent, or extract one using GI.extent.\nWe can crop our masked raster as well:\n\nout_image_mask_crop = Rasters.crop(out_image_mask; to = zion, touches = true)\n\n╭──────────────────────────────────────────╮\n│ 439×436 Raster{Union{Missing, UInt16},2} │\n├──────────────────────────────────────────┴───────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(-113.22874987945141, -112.86374987947575, 439) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(37.50375009649975, 37.14125009652391, 436) ReverseOrdered Regular Intervals{Start}\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-113.22874987945141, -112.86291654614247), Y = (37.14125009652391, 37.504583429833026))\n  missingval: missing\n  crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →    37.5038    37.5029    …  37.1429    37.1421    37.1413\n -113.229    missing    missing       missing    missing    missing\n -113.228    missing    missing       missing    missing    missing\n -113.227    missing    missing       missing    missing    missing\n -113.226    missing    missing       missing    missing    missing\n    ⋮                            ⋱              ⋮         \n -112.867    missing    missing  …    missing    missing    missing\n -112.866    missing    missing       missing    missing    missing\n -112.865    missing    missing       missing    missing    missing\n -112.865    missing    missing       missing    missing    missing\n -112.864    missing    missing       missing    missing    missing\n\n\nand we write it to file using Rasters.write:\n\nRasters.write(\"output/srtm_masked_cropped.tif\", out_image_mask_crop; force = true)\n\n[ Info: `missingval` set to 65535 on disk\n\n\n\"output/srtm_masked_cropped.tif\"\n\n\nFigure 6.1 shows the original raster, and the three masking and/or cropping results.\n\nfig = Figure(size = (600, 600))\n\nax1 = Axis(fig[1, 1]; title = \"Original\")\nplot!(ax1, src_srtm)\npoly!(ax1, zion.geom; color = :transparent, strokecolor = :black, strokewidth = 0.75)\n\nax2 = Axis(fig[1, 2]; title = \"Masked\")\nplot!(ax2, out_image_mask)\npoly!(ax2, zion.geom; color = :transparent, strokecolor = :black, strokewidth = 0.75)\n\nax3 = Axis(fig[2, 1]; title = \"Cropped\")\nplot!(ax3, out_image_crop)\npoly!(ax3, zion.geom; color = :transparent, strokecolor = :black, strokewidth = 0.75)\n\nax4 = Axis(fig[2, 2]; title = \"Masked+Cropped\")\nplot!(ax4, out_image_mask_crop)\npoly!(ax4, zion.geom; color = :transparent, strokecolor = :black, strokewidth = 0.75)\n\ndisplay(fig)\n\n\n\n\n\n\n\n\n\n\n(a) Raster masking and cropping\n\n\n\n\n\n\n\nCairoMakie.Screen{PDF}\n\n\n(b)\n\n\n\n\n\nFigure 6.1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html#sec-raster-extraction",
    "href": "chapters/05-raster-vector.html#sec-raster-extraction",
    "title": "6  Raster-vector interactions",
    "section": "6.3 Raster extraction",
    "text": "6.3 Raster extraction\nRaster extraction is the process of identifying and returning the values associated with a ‘target’ raster at specific locations, based on a (typically vector) geographic ‘selector’ object. The reverse of raster extraction—assigning raster cell values based on vector objects—is rasterization, described in Section 6.4.\nRasters.jl provides modular raster extraction and statistics functions, and we use this package in the following examples.\n\nTo points (Section 6.3.1) or to lines (Section 6.3.2), via the Rasters.extract function\nTo polygons (Section 6.3.3), via the Rasters.zonal function\n\n\n6.3.1 Extraction to points\nThe simplest type of raster extraction is getting the values of raster cells at specific points. To demonstrate extraction to points, we will use zion_points, which contains a sample of 30 locations within the Zion National Park (Figure 6.2).\n\nfig, ax, plt = plot(src_srtm)\nscatter!(ax, zion_points.geom, color=:black, strokecolor=:white, strokewidth = 1);\ndisplay(fig)\n\n\n\n\n\n\n\n\n\n\n(a) 30 point locations within the Zion National Park, with elevation in the background\n\n\n\n\n\n\n\nCairoMakie.Screen{PDF}\n\n\n(b)\n\n\n\n\n\nFigure 6.2\n\n\n\n\nThe following expression extracts elevation values from srtm.tif according to zion_points, using Rasters.extract.\n\nThe API here is not great, can we do better? It currently returns a vector of named tuples, which is not very convenient.\nOne thought is to use a Tables.jl materializer to convert the result if possible. I understand the desire to return the geometry values. But there must be a better way than this.\n\n\nresult1 = DataFrame(Rasters.extract(src_srtm, zion_points; geometry = false))\n\n30×1 DataFrame24 rows omitted\n\n\n\nRow\n\n\n\n\nUInt16?\n\n\n\n\n1\n1802\n\n\n2\n2433\n\n\n3\n1886\n\n\n⋮\n⋮\n\n\n28\n1372\n\n\n29\n1905\n\n\n30\n1574\n\n\n\n\n\n\nThe first argument is the raster from which to extract values, and the second is the vector object (or collection of objects) according to which to extract the values.\n\n\n\n\n\n\nNote\n\n\n\nRasters.jl does not yet support interpolation in extraction, so the values extracted are the values of the nearest cell center.\nThis corresponds to interpolate='nearest' in the Python rasterstats package.\n\n\nEither way, the resulting object is a vector of raster values, corresponding to zion_points. For example, here are the elevations of the first five points.\n\nresult1[1:5, \"\"]\n\n5-element Vector{Union{Missing, UInt16}}:\n 0x070a\n 0x0981\n 0x075e\n 0x055a\n 0x05ac\n\n\nTo get a DataFrame with the original points geometries (and other attributes, if any), as well as the extracted raster values, we can assign the extraction result into a new column.\n\nzion_points[!, \"elev1\"] = result1[!, \"\"]\nzion_points\n\n30×2 DataFrame24 rows omitted\n\n\n\nRow\ngeom\nelev1\n\n\n\nIGeometr…\nUInt16?\n\n\n\n\n1\nGeometry: wkbPoint\n1802\n\n\n2\nGeometry: wkbPoint\n2433\n\n\n3\nGeometry: wkbPoint\n1886\n\n\n⋮\n⋮\n⋮\n\n\n28\nGeometry: wkbPoint\n1372\n\n\n29\nGeometry: wkbPoint\n1905\n\n\n30\nGeometry: wkbPoint\n1574\n\n\n\n\n\n\nYou can read from a single band by selecting the band in the Raster. TODO finish this text\n\n\n6.3.2 Extraction to lines\nRaster extraction is also applicable with line selectors. The typical line extraction algorithm is to extract one value for each raster cell touched by a line. However, this particular approach is not recommended to obtain values along the transects, as it is hard to get the correct distance between each pair of extracted raster values.\nFor line extraction, a better approach is to split the line into many points (at equal distances along the line) and then extract the values for these points using the “extraction to points” technique (Section 6.3.1). To demonstrate this, the code below creates (see ?sec-vector-data for recap) zion_transect, a straight line going from northwest to southeast of the Zion National Park.\n\ncoords = [[-113.2, 37.45], [-112.9, 37.2]]\nzion_transect = GI.LineString(coords)\n\nGeoInterface.Wrappers.LineString{false, false, Vector{Vector{Float64}}, Nothing, Nothing}([[-113.2, 37.45], [-112.9, 37.2]], nothing, nothing)\n\n\nThe utility of extracting heights from a linear selector is illustrated by imagining that you are planning a hike. The method demonstrated below provides an ‘elevation profile’ of the route (the line does not need to be straight), useful for estimating how long it will take by determining the cumulative elevation gain of your journey.\nFirst, we need to create a layer consisting of points along our line (zion_transect), at specified intervals (e.g., 250). To do that, we need to transform the line into a projected CRS (so that we work with true distances, in \\(m\\)), such as UTM.\n\nzion_transect_utm = GO.reproject(zion_transect; target_crs = GFT.EPSG(32612), source_crs = GFT.EPSG(4326))\n\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, EPSG{1}}([(305399.67208180577, 4.147066650206682e6), (331380.8917453843, 4.1187500947884847e6)], nothing, EPSG{1}((32612,)))\n\n\nThe printout of the new geometry shows this is still a straight line between two points, only with coordinates in a projected CRS.\n\nI’ve chosen to differ from the Python treatment here - instead of selecting some number of points along the line explicitly, I will segmentize the line and extract the points. This is less precise, but we don’t have the API to do arclength interpolation in GeometryOps yet. Hopefully this will be added soon.\ncf. https://github.com/JuliaGeo/GeometryOps.jl/issues/210\n\nHere, we interpolate points along the line using GO.segmentize. This operation is sometimes called line densification.\nWe first compute the length of the line, and then use this to segmentize the line into approximately 250 points.\n\n_centroid, linelen = GO.centroid_and_length(zion_transect_utm)\n\n((318390.28191359504, 4.1329083724975833e6), 38429.82026966749)\n\n\nNow that we have the length of the line, we can choose a distance such that we get around 250 points along the line.\n\nzion_transect_line = GO.segmentize(zion_transect_utm; max_distance = linelen / 250)\n\nGeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, EPSG{1}}([(305399.67208180577, 4.147066650206682e6), (305503.59696046007, 4.146953383985009e6), (305607.5218391144, 4.1468401177633363e6), (305711.44671776873, 4.1467268515416635e6), (305815.37159642304, 4.1466135853199908e6), (305919.29647507734, 4.146500319098318e6), (306023.22135373164, 4.1463870528766452e6), (306127.14623238595, 4.1462737866549725e6), (306231.0711110403, 4.1461605204332997e6), (306334.9959896946, 4.1460472542116265e6)  …  (330445.5678374955, 4.11976949078354e6), (330549.4927161498, 4.119656224561867e6), (330653.41759480414, 4.119542958340194e6), (330757.34247345844, 4.1194296921185213e6), (330861.26735211274, 4.1193164258968486e6), (330965.19223076705, 4.119203159675176e6), (331069.11710942135, 4.119089893453503e6), (331173.0419880757, 4.1189766272318303e6), (331276.96686673, 4.1188633610101575e6), (331380.8917453843, 4.1187500947884847e6)], nothing, EPSG{1}((32612,)))\n\n\nThis gives us a collection of 251 points along the line. We can extract the points that define the line segments by using GI.getpoint on the line, and then reproject the points to the CRS of the raster.\n\nline_points = GI.getpoint(zion_transect_line)\nzion_transect_pnt = GO.reproject(line_points; target_crs = GI.crs(src_srtm), source_crs = GI.crs(zion_transect_line))\n\n251-element Vector{Tuple{Float64, Float64}}:\n (-113.2, 37.45)\n (-113.1987960226292, 37.449001661297636)\n (-113.19759207733796, 37.448003309143594)\n (-113.1963881641247, 37.44700494353919)\n (-113.1951842829878, 37.44600656448574)\n (-113.19398043392566, 37.44500817198453)\n (-113.19277661693668, 37.444009766036885)\n (-113.19157283201925, 37.4430113466441)\n (-113.19036907917175, 37.4420129138075)\n (-113.18916535839257, 37.44101446752837)\n ⋮\n (-112.90956920045984, 37.20801281544639)\n (-112.90837293949568, 37.20701125948384)\n (-112.90717671022236, 37.20600969038492)\n (-112.90598051263827, 37.205008108150906)\n (-112.90478434674178, 37.2040065127831)\n (-112.90358821253133, 37.20300490428282)\n (-112.9023921100053, 37.20200328265134)\n (-112.90119603916204, 37.201001647889974)\n (-112.90000000000002, 37.20000000000002)\n\n\nFinally, we extract the elevation values for each point in our transect and combine the information with zion_transect_pnt (after “promoting” it to a DataFrame, to accommodate extra attributes), using the point extraction method shown earlier (Section 6.3.1). We also attach the distance of each point along the line, to be used to plot an elevation profile.\n\nzion_transect_pnt = DataFrame(geometry = zion_transect_pnt)\n\nresult = Rasters.extract(src_srtm, zion_transect_pnt; geometry = false)\n# `Rasters.extract` returns a vector of tuples, so we take the first element of each tuple\nresult = first.(result)\n# Add elevation data to a new data frame column, named `elevation`\nzion_transect_pnt[!, \"elevation\"] = result\n\n251-element Vector{UInt16}:\n 0x07d1\n 0x07f1\n 0x07e4\n 0x07c5\n 0x076e\n 0x074d\n 0x06fe\n 0x06e7\n 0x06d3\n 0x06ba\n      ⋮\n 0x0720\n 0x079f\n 0x0769\n 0x0737\n 0x072d\n 0x0737\n 0x0729\n 0x070a\n 0x06e3\n\n\nWe also want to visualize an elevation profile along this line, so we compute the distances along the line manually. Using GO.distance, we can get the distance between successive points along the line. Then, we add 0.0 to the beginning of the array of distances, and sum along that array to get the cumulative distance along the line.\n\n# Compute distances between successive points along the line\ndistances_between_points = GO.distance.(zion_transect_pnt.geometry[1:end-1], zion_transect_pnt.geometry[2:end])\n# Compute cumulative distances along the line\ncumulative_distances = cumsum([0.0; distances_between_points])\n# Assign the distances to a new column in the data frame\nzion_transect_pnt[!, \"distance\"] = cumulative_distances\nzion_transect_pnt\n\n251×3 DataFrame245 rows omitted\n\n\n\nRow\ngeometry\nelevation\ndistance\n\n\n\nTuple…\nUInt16\nFloat64\n\n\n\n\n1\n(-113.2, 37.45)\n2001\n0.0\n\n\n2\n(-113.199, 37.449)\n2033\n0.00156405\n\n\n3\n(-113.198, 37.448)\n2020\n0.00312808\n\n\n⋮\n⋮\n⋮\n⋮\n\n\n249\n(-112.902, 37.202)\n1833\n0.387393\n\n\n250\n(-112.901, 37.201)\n1802\n0.388953\n\n\n251\n(-112.9, 37.2)\n1763\n0.390513\n\n\n\n\n\n\nThe information in zion_transect_pnt, namely the \"dist\" and \"elev\" attributes, can now be used to draw an elevation profile, as illustrated in Figure 6.3.\n# Raster and a line transect\nfig, ax, plt = plot(src_srtm)\nlines!(ax, zion_transect; color = :black)\npoly!(ax, zion.geom; color = :transparent, strokecolor = :white, strokewidth = 0.75)\ndisplay(fig)\n# Elevation profile\nfig, ax, plt = lines(\n    zion_transect_pnt.distance, \n    zion_transect_pnt.elevation;\n    axis = (;\n        xlabel = \"Distance (m)\",\n        ylabel = \"Elevation (m)\",\n    )\n)\ndisplay(fig)\n\n\n\n\n\n\n\n\n\n\n\n(a) Raster and a line transect\n\n\n\n\n\n\n\n\n\n\n\n(b) Extracted elevation profile\n\n\n\n\n\n\n\n\n\n\nCairoMakie.Screen{PDF}\n\n\n(c)\n\n\n\n\n\n\n\nFigure 6.3: Extracting a raster values profile to line\n\n\n\n\n\n6.3.3 Extraction to polygons\nThe final type of geographic vector object that can be used for raster extraction is polygons.\nLike lines, polygons tend to return many raster values per vector geometry. For continuous rasters (Figure 6.4 (a)), we typically want to generate summary statistics for raster values per polygon, for example to characterize a single region or to compare many regions. The generation of raster summary statistics, by polygons, is demonstrated in the code below using Rasters.zonal, which creates a list of summary statistics (in this case a list of length 1, since there is just one polygon).\n\nusing Statistics # for `mean`\nrmean = Rasters.zonal(mean, src_srtm; of = zion)\nrmin = Rasters.zonal(minimum, src_srtm; of = zion)\nrmax = Rasters.zonal(maximum, src_srtm; of = zion)\nresult = (rmean, rmin, rmax)\n\n(Union{Missing, Float64}[1818.211830154405], Union{Missing, UInt16}[0x0462], Union{Missing, UInt16}[0x0a65])\n\n\nRasters.zonal accepts any function that works on iterables (collections of elements that can be looped over) and returns a single value, like mean, minimum, maximum, std, median, mode, sum, prod, etc.\n\n\n\n\n\n\nYou can pass your own custom function too!\n\n\n\n\n\n\n# This is about the worst possible implementation of a mean function,\n# please don't use it in real life!\nfunction my_mean(iterable)\n    result = 0.0\n    count = 0\n    for value in iterable\n        result += value\n        count += 1\n    end\n    result /= count\n    return result\nend\n\nRasters.zonal(my_mean, src_srtm; of = zion)\n\n1-element Vector{Union{Missing, Float64}}:\n 1818.211830154405\n\n\n\n\n\n\n\n\n\n\n\nYou can pass multiple functions to a single Rasters.zonal call\n\n\n\n\n\nSometimes, in order to be most efficient with raster access, we might want to pass multiple functions to a single Rasters.zonal call. We can do this by passing a function that returns a tuple of values to Rasters.zonal.\nFor example, consider:\n\nusing Statistics # for `mean`\nRasters.zonal(x -&gt; (mean(x), minimum(x), maximum(x)), src_srtm; of = zion)\n\n1-element Vector{Union{Missing, Tuple{Float64, UInt16, UInt16}}}:\n (1818.211830154405, 0x0462, 0x0a65)\n\n\n\n\n\nIt’s straightforward to transform the result to a DataFrame as well:\n\nDataFrame(mean = rmean, min = rmin, max = rmax)\n\n1×3 DataFrame\n\n\n\nRow\nmean\nmin\nmax\n\n\n\nFloat64?\nUInt16?\nUInt16?\n\n\n\n\n1\n1818.21\n1122\n2661\n\n\n\n\n\n\nBecause there is only one polygon in the example, single-element vectors are returned. However, if zion was composed of more than one polygon, we would accordingly get more elements in the returned vectors. The result provides useful summaries, for example that the maximum height in the park is 2661 \\(m\\) above sea level.\nTo count occurrences of categorical raster values within polygons (Figure 6.4 (b)), we can use masking (Section 6.2) combined with StatsBase.countmap, as follows.\n\nout_image = Rasters.mask(src_nlcd; with = GO.reproject(zion; target_crs = GI.crs(src_nlcd)))\nusing StatsBase\ncounts = StatsBase.countmap(out_image)\n\nDict{Union{Missing, UInt8}, Int64} with 8 entries:\n  0x05    =&gt; 203701\n  0x04    =&gt; 298299\n  0x06    =&gt; 235\n  0x07    =&gt; 62\n  0x02    =&gt; 4205\n  missing =&gt; 852741\n  0x08    =&gt; 679\n  0x03    =&gt; 98285\n\n\nAccording to the result, for example, the value 2 (“Developed” class) appears in 4205 pixels within the Zion polygon.\nFigure 6.4 illustrates the two types of raster extraction to polygons described above.\n# Continuous raster\nfig, ax, plt = plot(src_srtm)\npoly!(ax, zion.geom; color = :transparent, strokecolor = :black, strokewidth = 0.75)\ndisplay(fig)\n# Categorical raster\nfig, ax, plt = plot(src_nlcd; colormap = cgrad(:Set3; categorical = true), source = GI.crs(src_nlcd), axis = (; type = GeoAxis, dest = GI.crs(src_nlcd)))\npoly!(ax, zion.geom; source = GI.crs(zion.geom[1]), color = :transparent, strokecolor = :black, strokewidth = 0.75)\ncm = Colorbar(fig[1, 2], plt)\nax.xgridvisible = false\nax.ygridvisible = false\ndisplay(fig) # TODO: make GeoMakie better on small extents\n\n\n\n\n\n\n\n\n\n\n\n(a) Continuous raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Categorical raster\n\n\n\n\n\n\n\n\n\n\nCairoMakie.Screen{PDF}\n\n\n(c)\n\n\n\n\n\n\n\nFigure 6.4: Sample data used for continuous and categorical raster extraction to a polygon",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html#sec-rasterization",
    "href": "chapters/05-raster-vector.html#sec-rasterization",
    "title": "6  Raster-vector interactions",
    "section": "6.4 Rasterization",
    "text": "6.4 Rasterization\nRasterization is the conversion of vector objects into their representation in raster objects. Usually, the output raster is used for quantitative analysis (e.g., analysis of terrain) or modeling. As we saw in Chapter 2, the raster data model has some characteristics that make it conducive to certain methods. Furthermore, the process of rasterization can help simplify datasets because the resulting values all have the same spatial resolution: rasterization can be seen as a special type of geographic data aggregation.\nRasters.jl provides the Rasters.rasterize function for rasterizing vector data. To make this happen, we need to have some definition for a “template” grid, i.e., the “template” raster defining the extent, resolution and CRS of the output. We can also pass a pre-existing raster, in which case Rasters uses the existing grid definition.\nAs for the vector geometries and their associated values, the Rasters.rasterize function can take input in multiple ways: - ; data::FeatureCollection, fill::Symbol means that the values of the column passed to fill will be used to fill the raster. - ; data::Vector{Geometry}, fill::Vector means that the values passed to fill will be associated with each geometry in data and used to fill the raster. - ; data::Any, fill::Function calls fill with the current value\nFurthermore, we define how to handle multiple values burned into the same pixel, in the first argument called reducer.\nBy default, this is last, meaning that the last polygon to be rasterized takes precedence.\nHowever, we can pass any function that takes in an iterable and returns a single value, like mean, minimum, maximum, std, median, mode, sum, prod, etc.\nMany of these may not make sense to use but they are useful to know of.\nFurthermore, we define how to deal with multiple values burned into the same pixel, in the first argument called reducer. By default, this is last, meaning that the last polygon to be rasterized takes precedence. However, we can pass any function that takes in an iterable and returns a single value, like mean, minimum, maximum, std, median, mode, sum, prod, etc. Many of these may not make sense to use but they are useful to know of.\nFinally, we can set the fill value, which is the value that “unaffected” pixels get, with fill=0 being the default.\nHow the Rasters.rasterize function works with all of these various parameters will be made clear in the next examples.\nThe geographic resolution of the “template” raster has a major impact on the results: if it is too low (cell size is too large), the result may miss the full geographic variability of the vector data; if it is too high, computational times may be excessive. There are no simple rules to follow when deciding an appropriate geographic resolution, which is heavily dependent on the intended use of the results. Often the target resolution is imposed on the user, for example when the output of rasterization needs to be aligned to an existing raster.\nDepending on the input data, rasterization typically takes one of two forms which we demonstrate next:\n\nin point rasterization (Section 6.4.1), we typically choose how to treat multiple points: either to summarize presence/absence, point count, or summed attribute values (Figure 6.5)\nin line and polygon rasterization (Section 6.4.2), there are typically no such “overlaps” and we simply “burn” attribute values, or fixed values, into pixels coinciding with the given geometries (Figure 6.6)\n\n\n6.4.1 Rasterizing points\nTo demonstrate point rasterization, we will prepare a “template” raster that has the same extent and CRS as the input vector data cycle_hire_osm_projected (a dataset on cycle hire points in London, illustrated in Figure 6.5 (a)) and a spatial resolution of 1000 \\(m\\). To do that, we first take our point layer and transform it to a projected CRS.\n\ncycle_hire_osm_projected = GO.reproject(cycle_hire_osm; target_crs = GFT.EPSG(27700))\n\n540×6 DataFrame534 rows omitted\n\n\n\nRow\ngeom\nosm_id\nname\ncapacity\ncyclestreets_id\ndescription\n\n\n\nTuple…\nString\nString?\nFloat64?\nString?\nString?\n\n\n\n\n1\n(5.32354e5, 1.82858e5)\n108539\nWindsor Terrace\n14.0\nmissing\nmissing\n\n\n2\n(5.29848e5, 1.83337e5)\n598093293\nPancras Road, King's Cross\nmissing\nmissing\nmissing\n\n\n3\n(5.30636e5, 182609.0)\n772536185\nClerkenwell, Ampton Street\n11.0\nmissing\nmissing\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n538\n(5.32531e5, 1.78805e5)\n5121513755\nmissing\n5.0\nmissing\nmissing\n\n\n539\n(5.38723e5, 1.80836e5)\n5188912370\nmissing\nmissing\nmissing\nmissing\n\n\n540\n(5.38413e5, 1.80774e5)\n5188912371\nmissing\nmissing\nmissing\nmissing\n\n\n\n\n\n\nWe can then use the Rasters.rasterize function to rasterize the points.\n\nThis isn’t a great way to get an extent, but needs must. Currently we get the extent of cycle_hire_osm_projected by GI.extent(GI.LineString(cycle_hire_osm_projected.geom)).\nTrack https://github.com/geocompx/geocompjl/issues/5 to see if there’s a better way to get an extent from a vector of geometries.\n\nAs mentioned above, point rasterization can be a very flexible operation: the results depend not only on the nature of the template raster, but also on the the pixel “activation” method, namely the way we deal with multiple points matching the same pixel.\nTo illustrate this flexibility, we will try three different approaches to point rasterization (Figure 6.5 (b)-(d)). First, we create a raster representing the presence or absence of cycle hire points (known as presence/absence rasters). In this case, we transfer the value of 1 to all pixels where at least one point falls in. In the Rasters.jl framework, we use the Rasters.rasterize function, as described above. In this first example, we want to write the value 1 where the points are present, and 0 otherwise.\n\nch_raster1 = Rasters.rasterize(\n    last,                     # reducer\n    cycle_hire_osm_projected; # data\n    fill = 1, \n    size = (1000, 1000) # specify size in \"pixels\"\n)\n\n╭────────────────────────────────────────────────╮\n│ 1000×1000 Raster{Union{Missing, Int64},2} last │\n├────────────────────────────────────────────────┴─────────────────────── dims ┐\n  ↓ X Sampled{Float64} 523038.61452275474:15.684723604717:538707.653403867 ForwardOrdered Regular Intervals{Start},\n  → Y Sampled{Float64} 174934.65727249475:10.03675127048517:184961.37179170942 ForwardOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any}()\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (523038.61452275474, 538723.3381274717), Y = (174934.65727249475, 184971.40854297992))\n  missingval: missing\n└──────────────────────────────────────────────────────────────────────────────┘\n      ↓ →        1.74935e5  1.74945e5  …  1.84941e5  1.84951e5  1.84961e5\n      5.23039e5   missing    missing       missing    missing    missing\n      5.23054e5   missing    missing       missing    missing    missing\n 523070.0         missing    missing       missing    missing    missing\n      ⋮                                ⋱                        ⋮\n      5.38676e5   missing    missing       missing    missing    missing\n 538692.0         missing    missing       missing    missing    missing\n      5.38708e5   missing    missing   …   missing    missing    missing\n\n\nIn our second variant of point rasterization, we count the number of bike hire stations. To do that, we use the fixed value of 1 (same as in the last example), but this time combined with the reducer=sum argument. That way, multiple values burned into the same pixel are summed, rather than replaced keeping last (which is the default). The new output, ch_raster2, shows the number of cycle hire points in each grid cell.\n\nch_raster2 = Rasters.rasterize(\n    sum,                     # reducer\n    cycle_hire_osm_projected; # data\n    fill = 1, \n    size = (1000, 1000) # specify size in \"pixels\"\n)\n\n╭───────────────────────────────────────────────╮\n│ 1000×1000 Raster{Union{Missing, Int64},2} sum │\n├───────────────────────────────────────────────┴──────────────────────── dims ┐\n  ↓ X Sampled{Float64} 523038.61452275474:15.684723604717:538707.653403867 ForwardOrdered Regular Intervals{Start},\n  → Y Sampled{Float64} 174934.65727249475:10.03675127048517:184961.37179170942 ForwardOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any}()\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (523038.61452275474, 538723.3381274717), Y = (174934.65727249475, 184971.40854297992))\n  missingval: missing\n└──────────────────────────────────────────────────────────────────────────────┘\n      ↓ →        1.74935e5  1.74945e5  …  1.84941e5  1.84951e5  1.84961e5\n      5.23039e5   missing    missing       missing    missing    missing\n      5.23054e5   missing    missing       missing    missing    missing\n 523070.0         missing    missing       missing    missing    missing\n      ⋮                                ⋱                        ⋮\n      5.38676e5   missing    missing       missing    missing    missing\n 538692.0         missing    missing       missing    missing    missing\n      5.38708e5   missing    missing   …   missing    missing    missing\n\n\nThe cycle hire locations have different numbers of bicycles described by the capacity variable, raising the question, what is the capacity in each grid cell? To calculate that, in our third point rasterization variant we sum the field ('capacity') rather than the fixed values of 1.\nThis is extremely simple to run, but we will show how to do this two ways: first, by passing the column name in the feature collection to fill.\n\nch_raster3 = Rasters.rasterize(\n    sum,                     # reducer\n    cycle_hire_osm_projected; # data\n    fill = :capacity, \n    size = (1000, 1000) # specify size in \"pixels\"\n)\n\n╭──────────────────────────────────────────────────────╮\n│ 1000×1000 Raster{Union{Missing, Float64},2} capacity │\n├──────────────────────────────────────────────────────┴───────────────── dims ┐\n  ↓ X Sampled{Float64} 523038.61452275474:15.684723604717:538707.653403867 ForwardOrdered Regular Intervals{Start},\n  → Y Sampled{Float64} 174934.65727249475:10.03675127048517:184961.37179170942 ForwardOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any}()\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (523038.61452275474, 538723.3381274717), Y = (174934.65727249475, 184971.40854297992))\n  missingval: missing\n└──────────────────────────────────────────────────────────────────────────────┘\n      ↓ →        1.74935e5  1.74945e5  …  1.84941e5  1.84951e5  1.84961e5\n      5.23039e5   missing    missing       missing    missing    missing\n      5.23054e5   missing    missing       missing    missing    missing\n 523070.0         missing    missing       missing    missing    missing\n      ⋮                                ⋱                        ⋮\n      5.38676e5   missing    missing       missing    missing    missing\n 538692.0         missing    missing       missing    missing    missing\n      5.38708e5   missing    missing   …   missing    missing    missing\n\n\nSecond, by passing the vectors of geometries and values separately.\n\nch_raster3 = Rasters.rasterize(\n    sum,                     # reducer\n    cycle_hire_osm_projected.geom; # data\n    fill = cycle_hire_osm_projected.capacity, \n    crs = GI.crs(cycle_hire_osm_projected),\n    size = (1000, 1000) # specify size in \"pixels\"\n)\n\n╭─────────────────────────────────────────────────╮\n│ 1000×1000 Raster{Union{Missing, Float64},2} sum │\n├─────────────────────────────────────────────────┴────────────────────── dims ┐\n  ↓ X Projected{Float64} 523038.61452275474:15.684723604717:538707.653403867 ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} 174934.65727249475:10.03675127048517:184961.37179170942 ForwardOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any}()\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (523038.61452275474, 538723.3381274717), Y = (174934.65727249475, 184971.40854297992))\n  missingval: missing\n  crs: EPSG:27700\n└──────────────────────────────────────────────────────────────────────────────┘\n      ↓ →        1.74935e5  1.74945e5  …  1.84941e5  1.84951e5  1.84961e5\n      5.23039e5   missing    missing       missing    missing    missing\n      5.23054e5   missing    missing       missing    missing    missing\n 523070.0         missing    missing       missing    missing    missing\n      ⋮                                ⋱                        ⋮\n      5.38676e5   missing    missing       missing    missing    missing\n 538692.0         missing    missing       missing    missing    missing\n      5.38708e5   missing    missing   …   missing    missing    missing\n\n\nThe input point layer cycle_hire_osm_projected and the three variants of rasterizing it ch_raster1, ch_raster2, and ch_raster3 are shown in Figure 6.5.\n# Input points\nnonmissing_df = dropmissing(cycle_hire_osm_projected, [:capacity, :geom])\nf, a, p = scatter(nonmissing_df.geom; color = nonmissing_df.capacity)\nColorbar(f[1, 2], p)\ndisplay(f)\n# Presence/Absence\nplot(ch_raster1) |&gt; display\n# Point counts\nplot(ch_raster2) |&gt; display\n# Summed attribute values\nplot(ch_raster3)\n\n\n\n\n\n\n\n\n\n\n\n(a) Input points\n\n\n\n\n\n\n\n\n\n\n\n(b) Presence/Absence\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) Point counts\n\n\n\n\n\n\n\n\n\n\n\n(d) Summed attribute values\n\n\n\n\n\n\n\nFigure 6.5: Original data and three variants of point rasterization\n\n\n\n\n\n6.4.2 Rasterizing lines and polygons\nAnother dataset based on California’s polygons and borders (created below) illustrates rasterization of lines. There are three preliminary steps. First, we subset the California polygon.\n\ncalifornia = us_states[ us_states[!, \"NAME\"] .== \"California\", :]\n\n1×7 DataFrame\n\n\n\nRow\ngeom\nGEOID\nNAME\nREGION\nAREA\ntotal_pop_10\ntotal_pop_15\n\n\n\nIGeometr…\nString\nString\nString\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\nGeometry: wkbMultiPolygon\n06\nCalifornia\nWest\n4.09747e5\n3.66373e7\n3.84215e7\n\n\n\n\n\n\nSecond, we obtain the borders of the polygon as a `‘MultiLineString’\n\ncalifornia_geom = only(california.geom)\ncalifornia_borders = GI.MultiLineString(GI.LineString.(GI.getexterior.(GI.getgeom(california_geom))); crs = GI.crs(california_geom)) # TODO: make this a lot better....\n\nGeoInterface.Wrappers.MultiLineString{false, false, Vector{GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}[GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}(Geometry: LINEARRING (-118.603375 33.478098,-118.368301 33.4 ... 8098), nothing, nothing), GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}(Geometry: LINEARRING (-118.605534 33.030999,-118.369984 32.8 ... 0999), nothing, nothing), GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}(Geometry: LINEARRING (-119.919155 34.07728,-119.755521 34.05 ... 7728), nothing, nothing), GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}(Geometry: LINEARRING (-120.247393 34.001911,-120.073609 34.0 ... 1911), nothing, nothing), GeoInterface.Wrappers.LineString{false, false, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}, Nothing, Nothing}(Geometry: LINEARRING (-124.211605 41.99846,-123.347562 41.99 ... 9846), nothing, nothing)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]]\"))\n\n\nFinally, we rasterize california_borders on a grid with resolution of 0.5 degrees per pixel.\n\ncalifornia_raster1 = Rasters.rasterize(\n    last,\n    california_borders;\n    fill = 1,\n    res = 0.5, # degrees - this is in units of GI.crs(california_borders)\n    boundary = :touches,\n)\n\n╭────────────────────────────────────────────╮\n│ 20×18 Raster{Union{Missing, Int64},2} last │\n├────────────────────────────────────────────┴─────────────────────────── dims ┐\n  ↓ X Sampled{Float64} -124.409591:0.5:-114.909591 ForwardOrdered Regular Intervals{Start},\n  → Y Sampled{Float64} 32.534156:0.5:41.034156 ForwardOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any}()\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-124.409591, -114.409591), Y = (32.534156, 41.534156))\n  missingval: missing\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →   32.5342    33.0342    33.5342    …  40.0342    40.5342    41.0342\n -124.41    missing    missing    missing      1          1          1\n -123.91    missing    missing    missing       missing    missing    missing\n -123.41    missing    missing    missing       missing    missing    missing\n    ⋮                                      ⋱                        \n -115.91   1           missing    missing       missing    missing    missing\n -115.41   1           missing    missing       missing    missing    missing\n -114.91   1          1          1         …    missing    missing    missing\n\n\nCompare it to a polygon rasterization, with all_touched=False (the default), which selects only raster cells whose centroids are inside the selector polygon, as illustrated in Figure 6.6 (right).\n\ncalifornia_raster2 = Rasters.rasterize(\n    last, \n    california;\n    geometrycolumn = :geom,\n    fill = 1,\n    res = 0.5,\n    boundary = :center,\n)\n\n╭────────────────────────────────────────────╮\n│ 20×18 Raster{Union{Missing, Int64},2} last │\n├────────────────────────────────────────────┴─────────────────────────── dims ┐\n  ↓ X Sampled{Float64} -124.409591:0.5:-114.909591 ForwardOrdered Regular Intervals{Start},\n  → Y Sampled{Float64} 32.534156:0.5:41.034156 ForwardOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any} with 1 entry:\n  \"missed_geometries\" =&gt; Bool[0]\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (-124.409591, -114.409591), Y = (32.534156, 41.534156))\n  missingval: missing\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →   32.5342    33.0342    33.5342    …  40.0342    40.5342    41.0342\n -124.41    missing    missing    missing      1          1           missing\n -123.91    missing    missing    missing      1          1          1\n    ⋮                                      ⋱                        \n -115.91   1          1          1              missing    missing    missing\n -115.41   1          1          1              missing    missing    missing\n -114.91   1           missing   1         …    missing    missing    missing\n\n\nTo illustrate which raster pixels are actually selected as part of rasterization, we also show them as points. This also requires the following code section to calculate the points, which we explain in Section 6.5.\n\nDimPointsConstructing from lookups\n\n\n\ndp = DimPoints(california_raster1)\n\n╭────────────────────────────────────────────╮\n│ 20×18 DimPoints{Tuple{Float64, Float64},2} │\n├────────────────────────────────────────────┴─────────────────────────── dims ┐\n  ↓ X Sampled{Float64} -124.409591:0.5:-114.909591 ForwardOrdered Regular Intervals{Start},\n  → Y Sampled{Float64} 32.534156:0.5:41.034156 ForwardOrdered Regular Intervals{Start}\n└──────────────────────────────────────────────────────────────────────────────┘\n    ↓ →   32.5342               33.0342               …  41.0342\n -124.41    (-124.41, 32.5342)    (-124.41, 33.0342)       (-124.41, 41.0342)\n -123.91    (-123.91, 32.5342)    (-123.91, 33.0342)       (-123.91, 41.0342)\n -123.41    (-123.41, 32.5342)    (-123.41, 33.0342)       (-123.41, 41.0342)\n -122.91    (-122.91, 32.5342)    (-122.91, 33.0342)       (-122.91, 41.0342)\n    ⋮                                                 ⋱  \n -116.91    (-116.91, 32.5342)    (-116.91, 33.0342)       (-116.91, 41.0342)\n -116.41    (-116.41, 32.5342)    (-116.41, 33.0342)       (-116.41, 41.0342)\n -115.91    (-115.91, 32.5342)    (-115.91, 33.0342)       (-115.91, 41.0342)\n -115.41    (-115.41, 32.5342)    (-115.41, 33.0342)       (-115.41, 41.0342)\n -114.91    (-114.91, 32.5342)    (-114.91, 33.0342)  …    (-114.91, 41.0342)\n\n\n\n\nDimensionalData.jl (which underpins Rasters.jl) provides easy ways to get “lookups”, i.e, axis index values, from a raster.\nNote that these lookups may encode intervals, points, or anything in between - so you should use shiftlocus or set to get the actual point values! DimPoints does this for you.\nBut if you want to see how this can be done automatically, here you go.\n\n[(x, y) for x in dims(california_raster1, X), y in dims(california_raster1, Y)]\n\n20×18 Matrix{Tuple{Float64, Float64}}:\n (-124.41, 32.5342)  (-124.41, 33.0342)  …  (-124.41, 41.0342)\n (-123.91, 32.5342)  (-123.91, 33.0342)     (-123.91, 41.0342)\n (-123.41, 32.5342)  (-123.41, 33.0342)     (-123.41, 41.0342)\n (-122.91, 32.5342)  (-122.91, 33.0342)     (-122.91, 41.0342)\n (-122.41, 32.5342)  (-122.41, 33.0342)     (-122.41, 41.0342)\n (-121.91, 32.5342)  (-121.91, 33.0342)  …  (-121.91, 41.0342)\n (-121.41, 32.5342)  (-121.41, 33.0342)     (-121.41, 41.0342)\n (-120.91, 32.5342)  (-120.91, 33.0342)     (-120.91, 41.0342)\n (-120.41, 32.5342)  (-120.41, 33.0342)     (-120.41, 41.0342)\n (-119.91, 32.5342)  (-119.91, 33.0342)     (-119.91, 41.0342)\n (-119.41, 32.5342)  (-119.41, 33.0342)  …  (-119.41, 41.0342)\n (-118.91, 32.5342)  (-118.91, 33.0342)     (-118.91, 41.0342)\n (-118.41, 32.5342)  (-118.41, 33.0342)     (-118.41, 41.0342)\n (-117.91, 32.5342)  (-117.91, 33.0342)     (-117.91, 41.0342)\n (-117.41, 32.5342)  (-117.41, 33.0342)     (-117.41, 41.0342)\n (-116.91, 32.5342)  (-116.91, 33.0342)  …  (-116.91, 41.0342)\n (-116.41, 32.5342)  (-116.41, 33.0342)     (-116.41, 41.0342)\n (-115.91, 32.5342)  (-115.91, 33.0342)     (-115.91, 41.0342)\n (-115.41, 32.5342)  (-115.41, 33.0342)     (-115.41, 41.0342)\n (-114.91, 32.5342)  (-114.91, 33.0342)     (-114.91, 41.0342)\n\n\nYou can see that this encodes the same values as dp in the other tab.\nTODO: firm up the description here and add links.\n\n\n\nFigure 6.6 shows the input vector layer, the rasterization results, and the points pnt.\n# Line rasterization\nfig, ax, plt = plot(california_raster1; colormap = cgrad(:Set3; categorical = true))\nlines!(ax, california_borders; color = :darkgrey, linewidth = 1)\nscatter!(ax, vec(dp); markersize = 3, color = :black)\ndisplay(fig)\n# Polygon rasterization\nfig, ax, plt = plot(california_raster2; colormap = cgrad(:Set3; categorical = true))\nlines!(ax, california_borders; color = :darkgrey, linewidth = 1)\nscatter!(ax, vec(dp); markersize = 3, color = :black)\nfig\n\n\n\n\n\n\n\n\n\n\n\n(a) Line rasterization w/ boundary=:touches\n\n\n\n\n\n\n\n\n\n\n\n(b) Polygon rasterization w/ boundary=:center\n\n\n\n\n\n\n\nFigure 6.6: Examples of line and polygon rasterization",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html#sec-spatial-vectorization",
    "href": "chapters/05-raster-vector.html#sec-spatial-vectorization",
    "title": "6  Raster-vector interactions",
    "section": "6.5 Spatial vectorization",
    "text": "6.5 Spatial vectorization\nSpatial vectorization is the counterpart of rasterization (Section 6.4). It involves converting spatially continuous raster data into spatially discrete vector data such as points, lines or polygons. There are three standard methods to convert a raster to a vector layer, which we cover next:\n\nRaster to polygons (Section 6.5.1)—converting raster cells to rectangular polygons, representing pixel areas\nRaster to points (Section 6.5.2)—converting raster cells to points, representing pixel centroids\nRaster to contours (Section 6.5.3)\n\nLet us demonstrate all three in the given order.\n\n6.5.1 Raster to polygons\nRasters.jl does not currently have a function to convert a raster to a feature collection with one polygon per pixel or cell. This is a similar situation in Python with rasterio.\nGeometryOps.jl offers a polygonize function that returns a feature collection of polygons, where each feature has a value property that encodes the value of all pixels within that polygon. Each polygon contains pixels with the same value.\n\nfc = GO.polygonize(src_grain)\n\nGeoInterface.Wrappers.FeatureCollection{Vector{GeoInterface.Wrappers.Feature{@NamedTuple{geometry::GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}, value::UInt8}, WellKnownText{GeoFormatTypes.CRS}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}}, WellKnownText{GeoFormatTypes.CRS}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}(GeoInterface.Wrappers.Feature{@NamedTuple{geometry::GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}, value::UInt8}, WellKnownText{GeoFormatTypes.CRS}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}[GeoInterface.Wrappers.Feature{@NamedTuple{geometry::GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}, value::UInt8}, WellKnownText{GeoFormatTypes.CRS}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}((geometry = GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(1.5, 1.5), (1.5, 3.5), (2.5, 3.5), (2.5, 4.5), (0.5, 4.5), (0.5, 1.5), (1.5, 1.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 2.5), Y = (1.5, 4.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 2.5), Y = (1.5, 4.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(1.5, 1.5), (1.5, 0.5), (2.5, 0.5), (2.5, 1.5), (1.5, 1.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 2.5), Y = (0.5, 1.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 2.5), Y = (0.5, 1.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(5.5, 5.5), (5.5, 6.5), (4.5, 6.5), (4.5, 5.5), (5.5, 5.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (4.5, 5.5), Y = (5.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (4.5, 5.5), Y = (5.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(4.5, 3.5), (3.5, 3.5), (3.5, 2.5), (2.5, 2.5), (2.5, 1.5), (4.5, 1.5), (4.5, 2.5), (5.5, 2.5), (5.5, 3.5), (4.5, 3.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 5.5), Y = (1.5, 3.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 5.5), Y = (1.5, 3.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 5.5), Y = (0.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), value = 0x00), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"), Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 5.5), Y = (0.5, 6.5)))), GeoInterface.Wrappers.Feature{@NamedTuple{geometry::GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}, value::UInt8}, WellKnownText{GeoFormatTypes.CRS}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}((geometry = GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(0.5, 4.5), (2.5, 4.5), (2.5, 3.5), (6.5, 3.5), (6.5, 5.5), (4.5, 5.5), (4.5, 4.5), (3.5, 4.5), (3.5, 5.5), (2.5, 5.5), (2.5, 6.5), (1.5, 6.5), (1.5, 5.5), (0.5, 5.5), (0.5, 4.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (3.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (3.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(1.5, 1.5), (0.5, 1.5), (0.5, 0.5), (1.5, 0.5), (1.5, 1.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (0.5, 1.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (0.5, 1.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(5.5, 2.5), (5.5, 1.5), (6.5, 1.5), (6.5, 2.5), (5.5, 2.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (1.5, 2.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (1.5, 2.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(2.5, 0.5), (3.5, 0.5), (3.5, 1.5), (2.5, 1.5), (2.5, 0.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 3.5), Y = (0.5, 1.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 3.5), Y = (0.5, 1.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), value = 0x01), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"), Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5)))), GeoInterface.Wrappers.Feature{@NamedTuple{geometry::GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}, value::UInt8}, WellKnownText{GeoFormatTypes.CRS}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}((geometry = GeoInterface.Wrappers.MultiPolygon{false, false, Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(1.5, 1.5), (2.5, 1.5), (2.5, 2.5), (3.5, 2.5), (3.5, 3.5), (1.5, 3.5), (1.5, 1.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 3.5), Y = (1.5, 3.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 3.5), Y = (1.5, 3.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(5.5, 5.5), (6.5, 5.5), (6.5, 6.5), (5.5, 6.5), (5.5, 5.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (5.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (5.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(4.5, 6.5), (2.5, 6.5), (2.5, 5.5), (3.5, 5.5), (3.5, 4.5), (4.5, 4.5), (4.5, 6.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 4.5), Y = (4.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 4.5), Y = (4.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(5.5, 0.5), (6.5, 0.5), (6.5, 1.5), (5.5, 1.5), (5.5, 2.5), (4.5, 2.5), (4.5, 1.5), (3.5, 1.5), (3.5, 0.5), (5.5, 0.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (3.5, 6.5), Y = (0.5, 2.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (3.5, 6.5), Y = (0.5, 2.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(6.5, 3.5), (5.5, 3.5), (5.5, 2.5), (6.5, 2.5), (6.5, 3.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (2.5, 3.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (2.5, 3.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{GeoFormatTypes.CRS}}([(1.5, 6.5), (0.5, 6.5), (0.5, 5.5), (1.5, 5.5), (1.5, 6.5)], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (5.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (5.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"))], Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5))), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\")), value = 0x02), WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"), Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5))))], WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\"), Extents.Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5))))\n\n\nWe can convert this “feature collection” to a DataFrame as follows. That makes it a lot easier to work with.\n\ndf = DataFrame([GI.properties(f) for f in GI.getfeature(fc)])\ndf.geometry = [GI.geometry(f) for f in GI.getfeature(fc)]\ndf\n\n3×2 DataFrame\n\n\n\nRow\nvalue\ngeometry\n\n\n\nUInt8\nMultiPol…\n\n\n\n\n1\n0\nMultiPolygon{false, false, Vector{Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(1.5, 1.5), (1.5, 3.5), (2.5, 3.5), (2.5, 4.5), (0.5, 4.5), (0.5, 1.5), (1.5, 1.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 2.5), Y = (1.5, 4.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 2.5), Y = (1.5, 4.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(1.5, 1.5), (1.5, 0.5), (2.5, 0.5), (2.5, 1.5), (1.5, 1.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 2.5), Y = (0.5, 1.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 2.5), Y = (0.5, 1.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(5.5, 5.5), (5.5, 6.5), (4.5, 6.5), (4.5, 5.5), (5.5, 5.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (4.5, 5.5), Y = (5.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (4.5, 5.5), Y = (5.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(4.5, 3.5), (3.5, 3.5), (3.5, 2.5), (2.5, 2.5), (2.5, 1.5), (4.5, 1.5), (4.5, 2.5), (5.5, 2.5), (5.5, 3.5), (4.5, 3.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 5.5), Y = (1.5, 3.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 5.5), Y = (1.5, 3.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 5.5), Y = (0.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))\n\n\n2\n1\nMultiPolygon{false, false, Vector{Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(0.5, 4.5), (2.5, 4.5), (2.5, 3.5), (6.5, 3.5), (6.5, 5.5), (4.5, 5.5), (4.5, 4.5), (3.5, 4.5), (3.5, 5.5), (2.5, 5.5), (2.5, 6.5), (1.5, 6.5), (1.5, 5.5), (0.5, 5.5), (0.5, 4.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (3.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (3.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(1.5, 1.5), (0.5, 1.5), (0.5, 0.5), (1.5, 0.5), (1.5, 1.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (0.5, 1.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (0.5, 1.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(5.5, 2.5), (5.5, 1.5), (6.5, 1.5), (6.5, 2.5), (5.5, 2.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (1.5, 2.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (1.5, 2.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(2.5, 0.5), (3.5, 0.5), (3.5, 1.5), (2.5, 1.5), (2.5, 0.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 3.5), Y = (0.5, 1.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 3.5), Y = (0.5, 1.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))\n\n\n3\n2\nMultiPolygon{false, false, Vector{Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(1.5, 1.5), (2.5, 1.5), (2.5, 2.5), (3.5, 2.5), (3.5, 3.5), (1.5, 3.5), (1.5, 1.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 3.5), Y = (1.5, 3.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (1.5, 3.5), Y = (1.5, 3.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(5.5, 5.5), (6.5, 5.5), (6.5, 6.5), (5.5, 6.5), (5.5, 5.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (5.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (5.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(4.5, 6.5), (2.5, 6.5), (2.5, 5.5), (3.5, 5.5), (3.5, 4.5), (4.5, 4.5), (4.5, 6.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 4.5), Y = (4.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (2.5, 4.5), Y = (4.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(5.5, 0.5), (6.5, 0.5), (6.5, 1.5), (5.5, 1.5), (5.5, 2.5), (4.5, 2.5), (4.5, 1.5), (3.5, 1.5), (3.5, 0.5), (5.5, 0.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (3.5, 6.5), Y = (0.5, 2.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (3.5, 6.5), Y = (0.5, 2.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(6.5, 3.5), (5.5, 3.5), (5.5, 2.5), (6.5, 2.5), (6.5, 3.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (2.5, 3.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (5.5, 6.5), Y = (2.5, 3.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\")), Polygon{false, false, Vector{LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}(LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}[LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, WellKnownText{CRS}}([(1.5, 6.5), (0.5, 6.5), (0.5, 5.5), (1.5, 5.5), (1.5, 6.5)], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (5.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 1.5), Y = (5.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))], Extent{(:X, :Y), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}((X = (0.5, 6.5), Y = (0.5, 6.5))), WellKnownText{CRS}(CRS(), \"GEOGCS[\\\\\"WGS 84\\\\\",DATUM[\\\\\"WGS_1984\\\\\",SPHEROID[\\\\\"WGS 84\\\\\",6378137,298.257223563,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"7030\\\\\"]],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"6326\\\\\"]],PRIMEM[\\\\\"Greenwich\\\\\",0,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"8901\\\\\"]],UNIT[\\\\\"degree\\\\\",0.0174532925199433,AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"9122\\\\\"]],AXIS[\\\\\"Latitude\\\\\",NORTH],AXIS[\\\\\"Longitude\\\\\",EAST],AUTHORITY[\\\\\"EPSG\\\\\",\\\\\"4326\\\\\"]]\"))\n\n\n\n\n\n\nThe polygon layer df is shown in Figure 6.7.\n\nf, a, p = poly(df.geometry; color = df.value, strokecolor = :black, strokewidth = 0.75)\nColorbar(f[1, 2], p)\nf\n\n\n\n\n\n\n\nFigure 6.7: grain.tif converted to a polygon layer\n\n\n\n\n\nAs highlighted using edgecolor='black', neighboring pixels sharing the same raster value are dissolved into larger polygons.\nOne suggestion is to add unique values between 0 and 0.9999 to all pixels, convert to polygons, and then get back to the original values using floor.\n\n\n6.5.2 Raster to points\nTo transform a raster to points, Rasters.jl provides the Rasters.DimTable constructor, which converts a raster into a lazy, table-like form. This can be converted directly to a DataFrame, or operated on independently.\n\ndt = DimTable(Raster(\"output/elev.tif\"))\n\nDimensionalData.DimTable with 36 rows, 3 columns, and schema:\n :X       Float64\n :Y       Float64\n :layer1  UInt8\n\n\nNotice that this has three columns, :X, :Y, and :layer1, corresponding to the pixel centroids and elevation values. But what if we want to treat the X and Y dimensionas as point geometries?\nDimTable has a mergedims keyword argument for this, which allows us to merge the X and Y dimensions into a single dimension.\n\ndt = DimTable(Raster(\"output/elev.tif\"), mergedims = (X, Y))\n\nDimensionalData.DimTable with 36 rows, 2 columns, and schema:\n :XY      Tuple{Float64, Float64}\n :layer1  UInt8\n\n\nThis has created a DimTable with a column :XY, which contains the pixel centroids as point-like objects. We can convert this to a DataFrame, set some metadata to indicate that geometry is in :XY, and plot the result.\n\ndf = DataFrame(dt)\nDataFrames.metadata!(df, \"GEOINTERFACE:geometrycolumns\", (:XY,); style = :note)\ndf\n\n36×2 DataFrame30 rows omitted\n\n\n\nRow\nXY\nlayer1\n\n\n\nTuple…\nUInt8\n\n\n\n\n1\n(-1.5, 1.0)\n1\n\n\n2\n(-1.0, 1.0)\n2\n\n\n3\n(-0.5, 1.0)\n3\n\n\n⋮\n⋮\n⋮\n\n\n34\n(-1.11022e-16, -1.5)\n34\n\n\n35\n(0.5, -1.5)\n35\n\n\n36\n(1.0, -1.5)\n36\n\n\n\n\n\n\n\nscatter(df.XY; color = df.layer1)\n\n\n\n\n\n\n\n\nWe can even save this to a file trivially easily:\n\nGeoDataFrames.write(\"output/elev.gpkg\", df)\nGeoDataFrames.read(\"output/elev.gpkg\")\n\n36×2 DataFrame30 rows omitted\n\n\n\nRow\nXY\nlayer1\n\n\n\nIGeometr…\nInt16\n\n\n\n\n1\nGeometry: wkbPoint\n1\n\n\n2\nGeometry: wkbPoint\n2\n\n\n3\nGeometry: wkbPoint\n3\n\n\n⋮\n⋮\n⋮\n\n\n34\nGeometry: wkbPoint\n34\n\n\n35\nGeometry: wkbPoint\n35\n\n\n36\nGeometry: wkbPoint\n36\n\n\n\n\n\n\nFigure 6.8 shows the input raster and the resulting point layer.\n# Input raster\nfig, ax, plt = plot(src_elev)\nscatter!(ax, df.XY; color = df.layer1)\ndisplay(fig)\n# Points\nfig, ax, plt = plot(src_elev; alpha = 0.1)\nscatter!(ax, df.XY; color = df.layer1, strokecolor = :black, strokewidth = 1)\nfig\n\n\n\n\n\n\n\n\n\n\n\n(a) Input raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Points\n\n\n\n\n\n\n\nFigure 6.8: Raster and point representation of elev.tif\n\n\n\nTODO: nodata pixels\n\n\n6.5.3 Raster to contours\nAnother common type of spatial vectorization is the creation of contour lines, representing lines of continuous height or temperatures (isotherms), for example. We will use a real-world digital elevation model (DEM) because the artificial raster elev.tif produces parallel lines (task for the reader: verify this and explain why this happens). Plotting contour lines is straightforward, using the contour or contourf functions in Makie.\n\nf, ax, plt = contour(src_dem; levels = LinRange(0, 1200, 50), color = :black)\n\n\n\n\n\n\n\n\nTODO: gdal_contour (via ArchGDAL??)\nIt would be good to show how to use the provided GDAL executables though…",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/05-raster-vector.html#sec-distance-to-nearest-geometry",
    "href": "chapters/05-raster-vector.html#sec-distance-to-nearest-geometry",
    "title": "6  Raster-vector interactions",
    "section": "6.6 Distance to nearest geometry",
    "text": "6.6 Distance to nearest geometry\nCalculating a raster of distances to the nearest geometry is an example of a “global” raster operation (?sec-global-operations-and-distances). To demonstrate it, suppose that we need to calculate a raster representing the distance to the nearest coast in New Zealand. This example also wraps many of the concepts introduced in this chapter and in previous chapters, such as raster aggregation (?sec-raster-agg-disagg), raster conversion to points (Section 6.5.2), and rasterizing points (Section 6.4.1).\nFor the coastline, we will dissolve the New Zealand administrative division polygon layer and “extract” the boundary as a 'MultiLineString' geometry.\n\nusing LibGEOS\ncoastline_linestrings = GI.getexterior.(GI.getgeom(LibGEOS.unaryUnion(GI.GeometryCollection(nz.geom)))) .|&gt; x -&gt; GI.LineString(collect(GI.getpoint(x)))\ncoastline = GI.MultiLineString(coastline_linestrings)\ncoastline = GO.reproject(coastline; target_crs = GI.crs(src_nz_elev), source_crs = GI.crs(nz))\n\nGeoInterface.Wrappers.MultiLineString{false, false, Vector{GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}(GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}[GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.2299979013e6, 4.7934322369e6), (1.2216031693e6, 4.7943017685e6), (1.2177895399e6, 4.7904898277e6), (1.2311152067e6, 4.787137924e6), (1.2361839211e6, 4.7843314255e6), (1.2325099445e6, 4.7718700237e6), (1.2173644933e6, 4.7681066692e6), (1.2080683451e6, 4.7605677875e6), (1.199129799e6, 4.7634183939e6), (1.1938565725e6, 4.7574957427e6)  …  (1.1964031733e6, 4.7848147499e6), (1.2011220591e6, 4.7884807601e6), (1.2003610396e6, 4.7969222422e6), (1.1955720567e6, 4.8084895651e6), (1.1989855975e6, 4.8153873633e6), (1.2077044806e6, 4.8171297889e6), (1.2161546733e6, 4.8132662203e6), (1.2184777781e6, 4.8064984488e6), (1.2297297347e6, 4.7987186067e6), (1.2299979013e6, 4.7934322369e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.1010682698e6, 4.9169506843e6), (1.0962776826e6, 4.9262213416e6), (1.1070468733e6, 4.9308841834e6), (1.1101943531e6, 4.9284267394e6), (1.1114045691e6, 4.9201779986e6), (1.1088006957e6, 4.914502166e6), (1.1010682698e6, 4.9169506843e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.2822947146e6, 4.8243903885e6), (1.2777592139e6, 4.8327835132e6), (1.2629460033e6, 4.8352306146e6), (1.2563895979e6, 4.832365038e6), (1.2436815529e6, 4.8358664271e6), (1.237141582e6, 4.8332854896e6), (1.2365580519e6, 4.8400088904e6), (1.2301828929e6, 4.8518834763e6), (1.2202312165e6, 4.8564065645e6), (1.2167650225e6, 4.8512224604e6)  …  (1.3536635084e6, 4.861558587e6), (1.3540190062e6, 4.8508162544e6), (1.3384831555e6, 4.837432841e6), (1.3299957273e6, 4.8375532567e6), (1.3247154647e6, 4.8316347032e6), (1.3151459743e6, 4.8300668586e6), (1.310825215e6, 4.826096002e6), (1.3025458256e6, 4.8269904113e6), (1.2945187261e6, 4.8232725043e6), (1.2822947146e6, 4.8243903885e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.1253763259e6, 4.982869816e6), (1.1248143323e6, 4.976641044e6), (1.1282897921e6, 4.9707170423e6), (1.1254201958e6, 4.9665221375e6), (1.1188173258e6, 4.9720125867e6), (1.1253763259e6, 4.982869816e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.7015121629e6, 5.9962048743e6), (1.6940719249e6, 5.9966701668e6), (1.6984728948e6, 5.9883324659e6), (1.7037685647e6, 5.9848085328e6), (1.7060307416e6, 5.9751359042e6), (1.7018195613e6, 5.9719674757e6), (1.6933144403e6, 5.9719708739e6), (1.6883953701e6, 5.9896812008e6), (1.6779656958e6, 6.0055889233e6), (1.662101242e6, 6.0277652897e6)  …  (1.725607508e6, 5.945892267e6), (1.7281682052e6, 5.9584185318e6), (1.7268710844e6, 5.9703482785e6), (1.7127870833e6, 5.9730682541e6), (1.7128762566e6, 5.9791634373e6), (1.7232886065e6, 5.9797407952e6), (1.7331650316e6, 5.9897140167e6), (1.7201965583e6, 5.9800776907e6), (1.709110421e6, 5.9866719829e6), (1.7015121629e6, 5.9962048743e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.6650793317e6, 5.4762796377e6), (1.6679650479e6, 5.4828286371e6), (1.6790721723e6, 5.4888496631e6), (1.6808040605e6, 5.4949012903e6), (1.6810365469e6, 5.4869445483e6), (1.6763032282e6, 5.4766970825e6), (1.6685295209e6, 5.4686427381e6), (1.6650793317e6, 5.4762796377e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.7939818643e6, 5.9319178426e6), (1.7912570345e6, 5.9199068808e6), (1.7842798937e6, 5.9215788138e6), (1.7818307229e6, 5.9258456737e6), (1.7939818643e6, 5.9319178426e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\")), GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, WellKnownText{GeoFormatTypes.CRS}}([(1.8266292121e6, 5.9745333354e6), (1.8188737655e6, 5.9791838569e6), (1.8185878044e6, 5.9830890239e6), (1.8112269977e6, 5.9881418267e6), (1.8126655001e6, 5.9932466009e6), (1.8093053687e6, 5.9982083619e6), (1.8108957047e6, 6.0059053369e6), (1.8159541251e6, 6.0078779063e6), (1.8180162185e6, 5.9990038299e6), (1.823326993e6, 5.9918794741e6), (1.8227997093e6, 5.9860917836e6), (1.8283790056e6, 5.9803071686e6), (1.8266292121e6, 5.9745333354e6)], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\"))], nothing, WellKnownText{GeoFormatTypes.CRS}(GeoFormatTypes.CRS(), \"PROJCS[\\\"unknown\\\",GEOGCS[\\\"unknown\\\",DATUM[\\\"Unknown based on GRS80 ellipsoid\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101004,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH]]\"))\n\n\nFor a “template” raster, we will aggregate the New Zealand DEM, in the nz_elev.tif file, to 5 times coarser resolution. The code section below follows the aggeregation example in ?sec-raster-agg-disagg.\n\nfactor = 2/10\nr = Rasters.resample(src_nz_elev; size = round.(Int, size(src_nz_elev) .* factor), method = :average)\n\n╭───────────────────────────────────────────╮\n│ 223×290 Raster{Union{Missing, Float32},2} │\n├───────────────────────────────────────────┴──────────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(995456.5461976258, 2.105456546197626e6, 223) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(6.186960927303582e6, 4.741960927303582e6, 290) ReverseOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata{Rasters.GDALsource} of Dict{String, Any} with 1 entry:\n  \"filepath\" =&gt; \"/vsimem/tmp\"\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (995456.5461976258, 2.110456546197626e6), Y = (4.741960927303582e6, 6.191960927303582e6))\n  missingval: missing\n  crs: PROJCS[\"unknown\",GEOGCS[\"unknown\",DATUM[\"Unknown based on GRS80 ellipsoid\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",173],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",1600000],PARAMETER[\"false_northing\",10000000],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]\n└──────────────────────────────────────────────────────────────────────────────┘\n ↓ →        6.18696e6  6.18196e6  …  4.75196e6  4.74696e6  4.74196e6\n 9.95457e5   missing    missing       missing    missing    missing\n 1.00046e6   missing    missing       missing    missing    missing\n ⋮                                ⋱                        ⋮\n 2.09546e6   missing    missing       missing    missing    missing\n 2.10046e6   missing    missing       missing    missing    missing\n 2.10546e6   missing    missing       missing    missing    missing\n\n\nThe resulting raster r and the lines layer coastline are plotted in Figure 6.9. Note that the raster values are average elevations based on \\(5 \\times 5\\) pixels, but this is irrelevant for the subsequent calculation; the raster is going to be used as a template, and all of its values will be replaced with distances to coastline (Figure 6.10).\n\nfig, ax, plt = plot(r)\nlines!(ax, coastline; color = :red)\nfig\n\n\n\n\n\n\n\nFigure 6.9: Template to calculate distance to nearest geometry (coastlines, in red)\n\n\n\n\n\nTo calculate the actual distances, we must convert each pixel to a vector (point) geometry. For this purpose, we use the technique demonstrated in Section 6.5.2, but simply select the pixels that are not missing.\n\ndp = DimPoints(r)\nnonmissing_points = dp[r .=== missingval(r)]\n\n53316-element Vector{Tuple{Float64, Float64}}:\n (995456.5461976258, 6.186960927303582e6)\n (1.0004565461976258e6, 6.186960927303582e6)\n (1.0054565461976257e6, 6.186960927303582e6)\n (1.0104565461976259e6, 6.186960927303582e6)\n (1.0154565461976258e6, 6.186960927303582e6)\n (1.0204565461976258e6, 6.186960927303582e6)\n (1.0254565461976258e6, 6.186960927303582e6)\n (1.0304565461976257e6, 6.186960927303582e6)\n (1.0354565461976259e6, 6.186960927303582e6)\n (1.0404565461976258e6, 6.186960927303582e6)\n ⋮\n (2.0654565461976258e6, 4.741960927303582e6)\n (2.0704565461976258e6, 4.741960927303582e6)\n (2.0754565461976258e6, 4.741960927303582e6)\n (2.0804565461976258e6, 4.741960927303582e6)\n (2.0854565461976258e6, 4.741960927303582e6)\n (2.0904565461976258e6, 4.741960927303582e6)\n (2.0954565461976258e6, 4.741960927303582e6)\n (2.100456546197626e6, 4.741960927303582e6)\n (2.105456546197626e6, 4.741960927303582e6)\n\n\nThe result is a vector of 2-tuples, which are recognized as GeoInterface point geometries.\nWe can compute the Cartesian distance from each point to the nearest line in the coastline multilinestring using the distance method from GeometryOps.\n\ndistances = GO.distance.((coastline,), nonmissing_points)\n\n53316-element Vector{Float64}:\n 572764.2876244619\n 567764.3239539921\n 562764.3609290748\n 557764.3985670706\n 552764.436885969\n 547764.4759044152\n 542764.5156417422\n 537764.5561180016\n 532764.5973539978\n 527764.639371324\n      ⋮\n 610809.9189554364\n 614562.8629679172\n 618333.460184955\n 622121.3896252689\n 625926.3366197749\n 629747.9927075815\n 633586.0555316888\n 637440.2287345697\n 641310.2218537896\n\n\nFinally, we rasterize (see Section 6.4.1) the distances into our raster template.\n\nimg = Rasters.rasterize(\n    last,\n    nonmissing_points;\n    to = r,\n    fill = distances,\n)\n\n╭────────────────────────────────────────────────╮\n│ 223×290 Raster{Union{Missing, Float64},2} last │\n├────────────────────────────────────────────────┴─────────────────────── dims ┐\n  ↓ X Projected{Float64} LinRange{Float64}(995456.5461976258, 2.105456546197626e6, 223) ForwardOrdered Regular Intervals{Start},\n  → Y Projected{Float64} LinRange{Float64}(6.186960927303582e6, 4.741960927303582e6, 290) ReverseOrdered Regular Intervals{Start}\n├──────────────────────────────────────────────────────────────────── metadata ┤\n  Metadata of Dict{Any, Any}()\n├────────────────────────────────────────────────────────────────────── raster ┤\n  extent: Extent(X = (995456.5461976258, 2.110456546197626e6), Y = (4.741960927303582e6, 6.191960927303582e6))\n  missingval: missing\n  crs: PROJCS[\"unknown\",GEOGCS[\"unknown\",DATUM[\"Unknown based on GRS80 ellipsoid\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],TOWGS84[0,0,0,0,0,0,0]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",173],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",1600000],PARAMETER[\"false_northing\",10000000],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]\n└──────────────────────────────────────────────────────────────────────────────┘\n ↓ →             6.18696e6  6.18196e6  …       4.74696e6       4.74196e6\n 9.95457e5       5.72764e5  5.72767e5     164188.0             1.67786e5\n 1.00046e6       5.67764e5  5.67767e5          1.60717e5  164391.0\n 1.00546e6       5.62764e5  5.62767e5          1.57329e5  161080.0\n ⋮                                     ⋱                       ⋮\n 2.09546e6       3.31952e5  3.29282e5          6.30403e5       6.33586e5\n 2.10046e6       3.36173e5  3.33536e5          6.34276e5       6.3744e5\n 2.10546e6  340415.0        3.37811e5          6.38166e5       6.4131e5\n\n\nThe final result, a raster of distances to the nearest coastline, is shown in Figure 6.10.\n\nfig, ax, plt = plot(img)\nlines!(ax, coastline; color = :red)\nColorbar(fig[1, 2], plt; label = \"Distance to coastline (m)\")\nfig\n\n\n\n\n\n\n\nFigure 6.10: Distance to nearest coastline in New Zealand",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster-vector interactions</span>"
    ]
  },
  {
    "objectID": "chapters/06-reproj.html",
    "href": "chapters/06-reproj.html",
    "title": "7  Reprojecting geographic data",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reprojecting geographic data</span>"
    ]
  },
  {
    "objectID": "chapters/07-read-write.html",
    "href": "chapters/07-read-write.html",
    "title": "8  Geographic data I/O",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Geographic data I/O</span>"
    ]
  },
  {
    "objectID": "chapters/08-mapping.html",
    "href": "chapters/08-mapping.html",
    "title": "9  Making maps with Julia",
    "section": "",
    "text": "Prerequisites",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Making maps with Julia</span>"
    ]
  }
]